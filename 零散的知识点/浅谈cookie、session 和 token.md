[toc]

# 浅谈Cookie、Session 和 token

## 1. 前言

由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是 Session。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的 Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存 Session 的方法很多，内存、数据库、文件都有。集群的时候也要考虑 Session 的转移，在大型的网站，一般会有专门的 Session 服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如 Memcached 之类的来放 Session。



思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现 Session 跟踪的，第一次创建 Session 的时候，服务端会在HTTP 协议中告诉客户端，需要在 Cookie 里面记录一个 Session ID，以后每次请求把这个会话 ID 发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。

所以，总结一下：
Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。





类似这种面试题，实际上都属于“开放性”问题，你扯到哪里都可以。不过如果我是面试官的话，我还是希望对方能做到一点——

**不要混淆 session 和 session 实现。**

本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。

 而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。

而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。

所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。





## 2. 客户端识别与 Cookie 机制

Web服务器可能会同时与数千个不同的客户端进行对话。这些服务器通常要记录下它们在于谁交谈，而不会认为所有的请求都来自于匿名的客户端。服务端识别其交谈对方的方式？

HTTP最初是一个匿名的、无状态的请求/响应协议。服务器处理来自客户端的请求，然后向客户端回送一条响应。Web服务器几乎没有什么信息可以用来判定是哪个用户发送的请求，也无法记录来访用户的请求序列。

HTTP 识别用户的几中技巧进行总结。每种技术都有其优势和劣势。

- 承载用户身份信息的HTTP首部
- 客户端 IP 地址跟踪，通过用户的 IP 地址对其进行识别
- 用户登录，用验证方式来识别用户
- 胖 URL，一种在 URL 中嵌入识别信息的技术
- cookie, 一种功能强大且高效的持久身份识别技术。

### 2.1 HTTP 首部

这里先讨论前三个，后面四个首部用于更高级的识别技术，稍后讨论。

表2.1-1 承载用户相关信息的HTTP首部

| 首部名称        | 首部类型     | 描述                                 |
| :-------------- | ------------ | ------------------------------------ |
| From            | 请求         | 用户的E-mail地址                     |
| User-Agent      | 请求         | 用户的浏览器软件                     |
| Referer         | 请求         | 用户是从这个页面上依照链接跳转过来的 |
| Authorization   | 请求         | 用户名和密码                         |
| Client-IP       | 扩展（请求） | 客户端的 IP 地址（稍后讨论）         |
| X-Forwarded-For | 扩展（请求） | 客户端的 IP 地址（稍后讨论）         |
| Cookie          | 扩展（请求） | 服务器产生的 ID 标签（稍后讨论）     |

From 首部包含了用户的E-mail地址。每个用户都有不同的E-mail地址，所以在理想情况下，可以将这个地址作为可行的源端来识别用户。但由于担心那些不讲武德的服务器会搜集这些E-mail，用于垃圾邮件的散发，所以很少有浏览器会发送From首部。实际上From首部一般由自动化的机器人或蜘蛛发送的，这样在出现问题时，网管还有个地方可以发送愤怒的投诉邮件。

User-Agent 首部可将用户所用浏览器的相关信息告知服务器，包括程序的名称和版本，通常还包含操作系统的相关信息。要实现定制内容与特定的浏览器及其属性间的良好互操作时，这个首部非常有用，但它并没有为识别特定的用户提供太多有意义的帮助。

Referer首部提共了用户来源页面的 URL。Referer 首部自身并不能完全识别用户，但它却是说明了用户之前访问过哪个页面。通过它可以更好地理解用户的浏览行为，以及用户的兴趣所在。比如，如果你是从一个篮球网站抵达某个Web服务器的，这个服务器可能会推断你是个篮球迷。

这三个首部都不足以实现可靠的识别。

### 2.2 客户端IP地址

早期的Web先锋曾尝试将客户端 IP 地址作为一种标识行为使用，如果每个用户都有不同的 IP 地址，IP地址（如果会发生变化的话）也很少会发生变化，而且Web 服务器可以判断出每条请求的客户端 IP 地址的话这种方案是可行的。通常在HTTP 首部并不提供客户端的 IP 地址，但Web 服务器可以找到承载 HTTP请求的 TCP 连接另一端的 IP 地址。

但是，使用客户端 IP 地址来识别用户存在着很多缺点，限制了将其作为用户识别技术的效能。

- 客户端 IP 地址描述的是所用的机器，而不是用户。如果多个用户共享同一台机器，就无法对其进行区分了。
- 很多因特网服务提供商都会在用户登录时动态为其动态分配 IP 地址。用户每次登录时，都会得到一个不同的地址，因此 Web 服务器不能假设 IP 地址可以在各登录会话之前标识用户。
- 为了提高安全性，并对稀缺的地址资源进行管理，很多用户都是通过网络地址转换（NAT）防火墙来浏览网络请求的。这些 NAT 设备隐藏了防火墙后面那些实际客户端的 IP 地址，将实际的客户端 IP 地址转换成一个共享的防火墙 IP 地址（和不通过的端口号）。
- HTTP 代理和网关通常会打开一些新的、到原始服务器的 TCP 连接。 Web 服务器看到的将是代理服务器的 IP 地址，而不是客户端的。有些代理为了绕过这个问题会添加特殊的 Client-IP 或者 X-Forwarded-For 扩展首部来保存原始的 IP 地址。但并不是所有的代理都支持这种行为。

少数站点甚至将客户端 IP 地址作为一种安全特性使用，它们只向来自特定 IP 地址的用户提供文档。在内部网络中可能可以这么做，但在因特网上就不行了，主要是因为因特网上 IP 地址太容易被欺骗（伪造）了。

### 2.3 用户登录

Web 服务器无需被动地根据用户的 IP 地址来猜测他的身份，它可以要求用户通过用户名和密码进行认证（登录）来显示地询问用户是谁。

为了使 Web 站点的登录更加简便，HTTP 中包含了一种内建机制，可以用www-Authenticate 首部和 Authorization 首部向 Web 站点传送用户的相关信息。一旦登录，浏览器就可以不断地在每条发往这个站点的请求中发送这个登录信息了，这样，就总是有登录信息可以用了。


















[toc]

# 项目依赖的版本范围控制浅谈

## 1. 前言

SemVer 的作者在其语义化版本控制 2.0 前言中写到：“在软件管理的世界里，有一个可怕的地方叫做’依赖地狱‘。你的系统越大，你集成到软件中的软件包越多，你就越有可能在某一天发现自己陷入绝望的深渊”。

的确，不论是前后端还是客户端服务端，随着项目的不断迭代，其中的依赖项将越来越多，绝大部分的依赖不同版本之间是存在很大差异的，特别是项目需要某些特定版本的依赖才能运行，这时候就需要明确依赖的版本。

这里明确依赖的版本有多种方式：

1. 直接固定某个依赖的版本，如 `1.1.1`，这样虽然可以做到固定版本，但并不能及时的获取到对应版本修复的错误，当有新的补丁级版本发布时，需要手动的修改成`1.1.2`才能更新。
2. 版本范围，如`^4.3.2` , 通过范围标识来实现版本的控制，这样既可以及时的获取到错误修复，又能固定某个版本。但是这样做需要一定的规范来约束，一般这样的约束在社区中都是明确规范的，如前端使用的是`node-semver`；不仅如此，这还需要我们开发人员明确各种不同的标识下接受的版本范围，这也是本文的主要内容。

下面是文章的两个主要内容：

1. 首先简单的描述一下 SemVer（Semantic Versioning）的基本规范
2. 就版本范围做详细的讲解，以 `node-semver` 中的内容为例

## 2. Semantic Versioning

语义化版本控制有一个巨大的好处，也是作者提到的，在这个方案下，版本号及其改变的方式直接传达了底层代码变化的含义，以及从一个版本到下一个版本所修改的大致信息。 

SemVer 将版本规定为：<b>主版本号.次版本号.补丁级版本号</b>（MAJOR.MINOR.PATCH）

- 主版本号：进行不兼容的 API 更改时，主版本号需要变化
- 次版本号：以向后兼容的方式添加功能时，次版本号变化
- 补丁版本号：向后兼容的错误修复时，补丁版本号变化。
- 预发布版本号或版本编译信息可以添加到“主版本号.次版本号.补丁级版本号”的后面，作为扩展。

关于语义化版本控制的详细信息可查看[Semantic Versioning 2.0.0](https://semver.org/)。

## 3. 版本范围控制详解

以下内容是基于 `node-semver` 为例，其它语言或有类似，或有不同。

版本范围控制主要是利用范围符号来实现，如`> < >= <= ~ ^`等，不同的符号指代不同的含义，下面就来一一说明。

### 3.1 基本范围符号

- `<` 小于，如`<1.2.3` 只要版本在 `0.0.0` 到 `1.2.3` 但不能是`1.2.3`的都是允许的
- `<=` 小于或等于
- `>`  大于
- `>=` 大于或等于
- `=` 等于，如果没有指定范围控制符，默认是`=`，因此这个符号是可选的

范围控制符号可以用空格连接起来形成一个控制交集，只有同时满足所有范围控制符号时才是被允许的，比如，`>=1.2.7 <1.3.0` 将会允许 `1.2.7`， `1.2.8` 以及  `1.2.99` 等，但是不允许 `1.2.6`,  `1.3.0`

范围控制符号可以用 `||` 连接起来形成一个控制并集，只要满足其中一个是被允许的，比如，`1.2.7 || >=1.2.9 <2.0.0`

将会允许 `1.2.7`, `1.2.9`以及`1.4.6`但是不允许`1.2.8` 或 `2.0.0`。

其实也就是空格相当于与（`&&`）, `||` 就是或了，优先级与更高嘛，更程序一样的。

### 3.2 预发布标签

如果版本是有预发布标签的，比如： `>1.2.3-alpha.3`，那么只有两种情况是被允许的：

1. 拥有预发布标签，且预发布标签大于`alpha.3`的并且 `主版本号.次版本号.补丁级版本号`完全相同，如`1.2.3-alpha.4`
2. 版本大于`1.2.3`但是没有预发布标签

比如： `>1.2.3-alpha.3`，那么`1.2.3-alpha.7`是允许的，而 `3.4.5-alpha.9`是不被允许的，尽管根据 `SemVer`排序规则，`3.4.5-alpha.9` 在技术上“大于” `1.2.3-alpha.3`，但是在 `node-semver` 中就是不被允许的。版本范围仅接受`1.2.3`上拥有预发布标签的。当然，如果版本上没有预发布标签，如`3.4.5`，那自然是满足的。

这种行为有两个目的:

1. 预发布版本经常更新得非常快，并且包含许多突破性的更改（根据作者的设计）还不适合公众使用。因此，默认情况下，它们被排除在范围匹配语义之外。

2. 选择使用预发布版本的用户已经明确表示了使用特定的alpha/beta/rc版本集的意图。通过在范围中包含预发布标签，用户表示他们意识到了风险。然而，假设他们选择在下一组预发布版本上承担类似的风险仍然是不合适的。

当然，虽然我们开发者很少使用，但是也可以了解，这种行为是可以配置的，通过将 `options` 对象上的 `includePrerelease` 标志设置为执行范围匹配的任何函数，可以阻止此行为（将所有预发布版本视为正常版本，以便进行范围匹配）。

### 3.2 高级范围语法

其实高级范围语法也只是原始基本范围语法的语法糖而已，高级范围同样可以使用空格或者 || 进行组合，方法与原始比较器相同。

#### 3.2.1 连字符 `X.Y.Z-A.B.C`

指定包含集

- `1.2.3 - 2.3.4` : 相当于 `>=1.2.3 <=2.3.4`

如果在指定包含集中第一个版本只提供了一部分，如`1.2 - 2.3.4`，那么，丢失的那部分将使用 `0`来代替。

- `1.2 - 2.3.4` 相当于 `>=1.2.0 <=2.3.4`

如果在指定包含集中第二个版本只提供了一部分，如`1.2.3 - 2.3`，那么以`2.3`作为开头的所有版本都会被接受，但是不能大于以 `2.3`开头的版本。

- `1.2.3 - 2.3` 相当于 `>=1.2.3 <2.4.0-0`
- `1.2.3 - 2` 相当于 `>=1.2.3 <3.0.0-0`

#### 3.2.2 X 符号 `1.2.x` `1.x` `1.2.*` `*`

`X`，`x`或者`*`中的任意一个都可以用于”替代“ `[主版本、次版本、补丁]`中任意一个数值。

- `*` 相当于`>=0.0.0`(也就是任意版本都满足)
- `1.x` 相当于 `>=1.0.0 < 2.0.0-0`(只需要匹配主版本就可满足)
- `1.2.x` 相当于 `>=1.2.0 <1.3.0-0`(只需要匹配主版本和次版本即可满足)

版本如果只写了一部分，丢失的部分将被视为X ，因此特殊字符(`x`或`*`)实际上是可选的。

- `""`  相当于`*`
- `1 `相当于`1.x.x`
- `1.2 `相当于`1.2.x`

#### 3.2.3 ~符号 `~1.2.3` `~1.2` `~1`

<b>如果次版本指定了的，如`~1.2.3` `~1.2`，那么补丁级的变化是允许的。如果次版本没有指定，如`~1`，那么次版本级的变化时允许的。</b>

- `~1.2.3` 相当于 `>=1.2.3 <1.3.0-0`
- `~1.2` 相当于 `>=1.2.0 <1.3.0-0` (也就是相当于1.2.x)
- `~1` 相当于 `>=1.0.0 <2.0.0-0`(这里次版本没指定，允许次版本级的变化，相当于`1.x`)
- `~0.2.3` 相当于 `>=0.2.3 <0.3.0-0`
- `~0.2` 相当于 `>=0.2.0 <0.3.0-0` (相当于`0.2.x`)
- `~0` 相当于 `>=0.0.0 <1.0.0-0` (这里次版本没指定，允许次版本级的变化，相当于`0.x`)
- `~1.2.3-beta.2` 相当于 `>=1.2.3-beta.2 <1.3.0-0` 注意：拥有预发布版本标签且大于等于`beta.2`且版本为`1.2.3`的是被允许的。因此`1.2.3-beta.4`是被允许的，但是`1.2.4-beta.2`是不被允许的，因为`1.2.4-beta.2`拥有预发布标签且不同的`[主版本、次版本、补丁]`

#### 3.2.4 ^ 符号 `^1.2.3` `^0.2.5` `^0.0.4`

<b>允许不修改最左侧非零元素的更改</b>

^ 符号指的是：指定的版本最左侧且非零的数值不修改的情况下的所有改变都是允许的。换句话说，对于版本`^1.0.0`，补丁级变化和次版本级变化都是允许的；对于版本`^0.1`，只有补丁级变化是允许的；对于版本`^0.0.1`，版本级的变化是不允许的。

当作者可以在0.2.4和0.3.0版本之间进行破坏性的更改时，插入符号范围是理想的，这是一种常见的做法。

当某依赖的的作者遵循在次版本升级（如`0.2.4` 到`0.3.0`）是指突破性更改时，使用^ 范围符号是非常理想的。因为在使用 ^ 范围符号是需要假设在 `0.2.4` 和 `0.2.5` 之间不存在破坏性更改。根据一般实践，它允许假定为增量型（但非破坏性）的变化。

- `^1.2.3` 相当于 `>=1.2.3 <2.0.0-0`
- `^0.2.3` 相当于 `>=0.2.3 <0.3.0-0`
- `^0.0.3` 相当于 `>=0.0.3 <0.0.4-0`
- `^1.2.3-beta.2` 相当于 `>=1.2.3-beta.2 <2.0.0-0` 
- `^0.0.3-beta` 相当于 `>=0.0.3-beta <0.0.4-0` 注意：这里拥有预发布版本且大于`beta`且版本为`0.0.3`的版本是被允许的，因此，`0.0.3-pr.2`是被允许的，当然`0.0.3`也是被允许的

在解析 ^ 符号时，丢失的版本值将被 “替换” 成0，但是允许该值具有灵活性，即便是主版本和次版本都为0的情况。

- `^1.2.x` 相当于 `>=1.2.0 <2.0.0-0`

- `^0.0.x` 相当于 `>=0.0.0 <0.1.0-0`

- `^0.0` 相当于 `>=0.0.0 <0.1.0-0`

- `^0.x` 相当于 `>=0.0.0 <1.0.0-0`

  

更多更详细的内容可以查看 [node-semver](https://github.com/npm/node-semver) 文档。

## 4. 项目中获取到的依赖版本

以下是基于 nodejs 而言，并且是在没有 package-lock.json 情况下：

通过 `npm i`  或者 `yarn` 安装项目依赖时，会根据 `package.json` 文件中的配置来进行获取，<b>获取到的依赖版本会在指定范围下获取到最新的版本</b>，示例如下：当`package.json` 中 webpack 的配置如下时：

1. `"webpack": "5.36.0"`: `node_modules` 中 webpack 的版本将会是 `5.36.0`
2. `"webpack": ">5.36.0"`: `node_modules` 中 webpack 的版本将会是 `5.38.1`, 获取到指定范围下最新版本
3. `"webpack": ">5.36.0 <=5.38.0":` `node_modules` 中 webpack 的版本将会是 `5.38.0`, 获取到指定范围下最新版本
4. `"webpack": "~1.0.0"`: `node_modules` 中 webpack 的版本将会是 `1.0.5`, 获取到指定范围下最新版本(范围为`>=1.0.0 <1.1.0`, 而`1.0.5` 便是 `1.0`的最后一个版本)
5. `"webpack": "~1"`: `node_modules` 中 webpack 的版本将会是 `1.15.0`, 获取到指定范围下最新版本(范围为`>=1.0.0 <2.0.0`, 而`1.15.0` 便是 `1` 主版本的最后一个版本)
6. `"webpack": "^4.25.1"`: `node_modules` 中 webpack 的版本将会是 `4.46.0`, 获取到指定范围下最新版本(范围为`>=4.25.1 <5.0.0`, 而`4.46.0` 便是 `4` 主版本的最后一个版本)
7. `"webpack": "^0.7.1"`: `node_modules` 中 webpack 的版本将会是 `0.7.17`, 获取到指定范围下最新版本(范围为`>=0.7.1 <0.8.0`, `0.7.17`是`0.7`下最新版本也就是最后一个版本)

## 5. 总结

一直在使用千奇百怪的依赖，每次都直接 `yarn add ` 或 `npm i`了，关于版本一直也没有关注过，这周在看 `vue3`的新知识的时候，发现有版本很多，而且带有一些奇怪的标志，特别是关于范围这一块更是懵圈的，所以就深入的去了解了一番。以前都是糊里糊涂的状态，这次好好的去扒文档看了，觉得很有意思，所以做个简单的记录吧！！

参考资料：

1. [package.json](https://docs.npmjs.com/cli/v6/configuring-npm/package-json)
2. [Semantic Versioning](https://semver.org/)
3. [node-semver](https://github.com/npm/node-semver)

## 6. Todo
1. package-lock.json
   lock 文件的出现和使用
2. Node 依赖是如何加载的
   那么多的相互依赖，重复依赖，node是怎么管理的


















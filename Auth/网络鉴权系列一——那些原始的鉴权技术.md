[toc]

# 网络鉴权系列一——那些原始的鉴权技术

## 1. 前言

HTTP并不是天生就具有丰富的识别特性。早期的 Web 站点设计者们都有自己的用户识别技术。每种技术都有其优势和劣势。本部分我们将讨论下列用户识别机制。

1. 承载用户身份信息的 HTTP 正式首部
2. 客户端 IP 地址跟踪，通过用户的 IP 地址对其进行识别
3. 用户登录，用认证方式来识别用户
4. 胖 URL，一种在 URL 中嵌入识别信息的技术 

这些技术虽然目前看来几乎被舍弃了的，但确实最为原始的网络鉴权技术，了解这些原始的鉴权技术对于我们的整个知识体系将有很大的助益。如想直接了解当前常用的鉴权技术，可直接调到第二部分。

## 2. 承载用户身份信息的 HTTP 正式首部

表 2-1给出了三种最常见的用来承载用户身份相关信息的 HTTP 请求首部（正式首部，非扩展）。

**表 2-1 三种最常见的承载用户身份相关信息的 HTTP 首部**

| 首部名称   | 首部类型 | 描述                                 |
| ---------- | -------- | ------------------------------------ |
| From       | 请求     | 用户的E-mail地址                     |
| User-Agent | 请求     | 用户的浏览器软件                     |
| Referer    | 请求     | 用户是从这个页面上依照链接跳转过来的 |

From 首部包含了用户的 E-mail 地址。每个用户都有不同的 E-mail 地址，所有在理想情况下，可以将这个地址作为可行的源端来识别用户。但由于担心那些不讲道德的服务器会搜集这些 E-mail 地址，用于垃圾邮件的散发，所以很少有浏览器会发送 From 首部。实际上，From 首部是由自动化的机器人或蜘蛛发送的，这样在出现问题时，网管还有个地方可以发送愤怒的投诉邮件。

User-Agent 首部可以将用户所用的浏览器的相关信息告知服务器，包括程序的名称和版本，通常还包含操作系统的相关信息。要实现定制内容与特定的浏览器及及其属性间的良好操作时，这个首部是非常有用的，但是它并没有为识别特定的用户提供太多有意义的帮助。下面是 Chrome 发送的 `User-Agent` 首部：

```http
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36
```

Referer 首部提供了用户来源页面的 URL。Referer 首部自身并不能完全表示用户，但它却是说明了用户之前访问过哪个页面。通过它可以更好的理解用户的浏览行为以及用户的新区所在。

From、User-Agent 和 Referer 首部都不足以实现可靠的识别。后面的小结对识别特定用户的策略进行了更为详细的讨论。

## 3. 客户端 IP 地址

早期的 Web 曾尝试着将客户端 IP 地址作为一种标识形式使用。如果每个用户都有不同的 IP 地址， IP地址（如果会发生变化的话）也很少会发生变化，而且 Web 服务器可以判断出每条请求的客户端 IP 地址的话，这种方案是可行的。通常在 HTTP 首部并不提供客户端的 IP 地址，但 Web 服务器可以找到承载 HTTP 请求的 TCP 连接另一端的 IP 地址。

比如，在 Unix 系统中，函数调用 getpeername 就可以返回发送端机器的客户端 IP 地址：

```sh
status = getpeername(tcp_connection_socket,...);
```

但是，使用客户端 IP 地址来识别用户存在很多的缺点，限制了将其作为用户识别技术的效能。

- 客户端 IP 地址描述的是所用的机器，而不是用户。如果多个用户共享一台计算机，就无法对其进行区分了。
- 很多因特网服务提供商都会在用户登录时为其动态分配 IP 地址。用户每次登录时，都会得到一个不同的地址，因此 Web 服务器不能假设 IP 地址可以在各登录会话之间标识用户。
- 为了提高安全性，并对稀缺的地址资源进行管理，很多用户都是通过网络地址转换(Network Address Translation, NAT)防火墙来浏览网络内容。这些 NAT 设备隐藏了防火墙后面那些实际客户端的 IP 地址，将实际的客户端 IP 地址转换成了一个共享的防火墙 IP 地址（和不同的端口号）。
- HTTP代理和网关通常会打开一些新的、到原始服务器的 TCP 连接。Web 服务器看到的将是代理服务器的 IP 地址，而不是客户端的。有些代理为了绕过这个问题会添加特殊的 `Client-IP` 或 `X-Forwarded-For` 扩展首部来保存原始的IP地址。但并不是所有的客户端都支持这种行为

如今几乎没有站点使用客户端 IP 地址在会话之间跟踪用户的行为，无法用 IP 地址确定目标的地方太多了。

但是客户端 IP 还有有些用处的，比如在内部网络中，可以将客户端 IP 地址作为一种安全特性使用，只想来自特定 IP 地址的用户提供文档。但在因特网上就不行，因为因特网上 IP 地址很容易被欺骗（伪造）了。

## 4. 用户登录

Web 服务器无序被动地根据用户的 IP 地址来猜测他的身份，它可以要求用户通过用户名和密码进行认证（登录）来显示地询问用户是谁。

为了使 Web 站点的登录更加简便， HTTP 中包含了一中内建机制，可以用 `WWW-Authenticate` 首部和`Authorization` 首部向 Web 站点传送用户的相关信息。一旦登录，，浏览器就可以不断地在每条发往这个站点的请求中发送这个登录信息了，这样，就总是有登录信息可用了。

如果服务器希望在为用户提供对站点的访问之前，先行登录，可以向浏览器回送一条 HTTP 响应代码 `401 Login Required`。然后，浏览器会显示一个登录对话框，并用 `Authorization` 首部在下一条对服务器的请求中提供这些信息。^2^图2-1对此进行了说明。

注2： 为了不让用户每发送一条请求就都要请求一次，大多数浏览器都会记住某站点的登录信息，并将登录信息放在发送给该站点的每条请求中。

![image-20210405124121006](/Users/aispeech/Desktop/MyGitHub/web-study-record/Auth/img/01/Authorization-process.png)

​																		**图2-1 用HTTP认证首部注册用户名**

上图发生的情况如下所述：

- 在图 2-1a 中，浏览器对站点 `www.arrow-zb.cn` 发起了一条请求。
- 站点并不知道这个用户的身份，因此在图 2-1b中，服务器会返回  `401 Login Required` HTTP响应码，并添加 `WWW-Authenticate` 首部，要求用户登录。这样浏览器就会弹出一个登录对话框。
- 只要用户输入了用户名和密码（对其身份进行完整性检查），浏览器就会重复原来的请求。这次它会添加一个 `Authorization` 首部，说明用户和密码。对用户名和密码进行加密，防止那些有意无意的网络观察者看到。
- 现在，服务器知道用户的身份了。
- 今后的请求要使用用户名和密码，浏览器会自动将存储下来的值发送出去，甚至在站点没有要求发送的时候也经常向其发送。浏览器在每次请求中都向服务器发送 `Authorization` 首部作为一种身份的标识，这样，只要登录一次，就可以在整个会话期间维持用户的身份了。

但是当用户切换到另一个站点时，这个标识就丢失掉了，再回到这个站点时，有需要再次的登录，同时，将用户名和密码直接放到 HTTP 首部中进行进行请求，也是非常危险的做法。

## 5. 胖URL

有些 Web 站点会为每个用户生成特定版本的 URL 来追踪用户的身份。通常，会对真正的 URL 进行扩展，在 URL 路径开始或者结束的地方添加一些状态信息。用户浏览站点时，Web 服务器会动态的生成一些超链，继续维护 URL 的状态信息。

改动后包含了用户状态信息的 URL 被称为胖 URL（fat URL）。如下所示就是一些胖 URL 的示例。每个 URL 后面都附加了一个用户特有的标识码（在这个例子中就是002-123456-7890 ），这个标识码有助于在用户浏览时对其进行跟踪。

```html
<a href="http://arrow-zb.cn/exec/test/-/ref=graf_/002-123456-7890">

<a href="/exec/obidos/tg/-/453621/ref=graf_/002-123456-7890">
```

可以通过胖 URL 将 Web 服务器上若干个独立的 HTTP 事务捆绑成一个“会话”或“访问”。用户首次访问这个 Web 站点时，会生成一个唯一的 ID，用服务器可以识别的方式将这个 ID 添加到 URL 中去，然后服务器就会将客户端重新导向这个胖 URL。不论什么时候，只要服务器收到了对胖 URL 的请求，就可以去查找与那个用户 ID 相关的所有增量状态（购物车、简介等），然后重写所有的输出超链，使其成为胖 URL，以维护用户的 ID。

可以在用户浏览站点时，用胖 URL 对其进行识别。但是这种技术存在几个很严重的问题。

- 丑陋的URL

  浏览器中显示的胖URL会给新用户带来困扰

- 无法共享URL

  胖 URL 中包含了与特定用户和会话有关的状态信息。如果将这个 URL 发送给其他人，可能就在无意中将你积累的个人信息都共享出去了

- 破坏缓存

  为每个 URL 生成用户特有的版本就以为这不再有可供公共访问的 URL 需要缓存了。

- 额外的服务器负荷

  服务器需要重写 HTML 页面使 URL 变胖

- 逃逸口

  用户跳转到其他站点或者请求一个特定的 URL 时，就很容易在无意中“逃离”胖URL会话。只有当用户严格地追随预先修改过的链接时，胖 URL 才能工作，如果用户逃离此链接，就会丢失他的进展信息，得重新开始。

- 在会话间是非持久的

  除非用户收藏了特定的胖 URL，否者用户退出登录时，所有的信息都会先丢失。

